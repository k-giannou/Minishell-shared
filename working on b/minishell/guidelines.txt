1 : readline
	#include <readline/readline.h>
	#include <readline/history.h>

	char *readline(const char *prompt);

	La fonction readline lit une ligne de texte depuis l'entrée standard
	et retourne cette ligne sous forme de chaîne de caractères.

	on doit liberer la chaine de charactere recuperee avec free.

		ex :
		char *input = readline("Entrez quelque chose: ");
    
		if (input)
		{
			printf("Vous avez entré: %s\n", input);
			free(input);  // Libère la mémoire allouée par readline()
		}



2 : rl_clear_history
	#include <readline/readline.h>
	#include <readline/history.h>

	void rl_clear_history(void);

	supprime l'historique de commandes de readline.

		ex :
		add_history("commande_1");
		add_history("commande_2");

		rl_clear_history();



3 : rl_on_new_line
	#include <readline/readline.h>
	#include <readline/history.h>

	void rl_on_new_line(void);

	force readline a lire sur une nouvelle ligne, ne change rien a ce que j'ai pu voir.

		ex :
		printf("Texte avant la nouvelle ligne.\n");

		// Forcer readline à placer le curseur sur une nouvelle ligne
		rl_on_new_line();
		
		// Demander une entrée après avoir explicitement sauté à la nouvelle ligne
		char *input = readline("Entrez quelque chose: ");
		
		if (input)
		{
			printf("Vous avez entré : %s\n", input);
			free(input);  // Libérer la mémoire allouée par readline
   		}



4 : rl_replace_line
	#include <readline/readline.h>
	#include <readline/history.h>

	int rl_replace_line(const char *text, int clear_undo);

	remplace la ligne actuelle dans le tampon de readline.
	Le premier paramètre, text, est la chaîne de caractères
	qui remplacera la ligne actuelle. Le second paramètre,
	clear_undo, indique si l'historique de modification de la
	ligne (le tampon d'annulation) doit être effacé ou non. Si
	clear_undo est non nul, l'annulation des modifications précédentes
	est désactivée.

		ex :
		int main()
		{
			char *line = readline("Entrez quelque chose : ");
			
			if (line)
			{
				// Remplacer la ligne actuelle par un texte différent
				rl_replace_line("Ligne remplacée!", 0);
				
				// Afficher la nouvelle ligne après remplacement
				printf("Ligne après remplacement : %s\n", rl_line_buffer);
				
				free(line);  // Libérer la mémoire allouée
			}
			
			return 0;
		}



5 : rl_redisplay
	#include <readline/readline.h>
	#include <readline/history.h>

	void rl_redisplay(void);

	refresh l'affichage si un changement exerne arrive.

		ex :
		int main()
		{
			char *input;

			input = readline("Entrez quelque chose: ");
			
			if (input)
			{
				// Supposons qu'un événement externe nécessite une mise à jour de l'affichage
				rl_redisplay();  // Redessine l'entrée actuelle dans readline
				
				printf("Vous avez entré: %s\n", input);
				free(input);  // Libère la mémoire allouée par readline
			}
			
			return 0;
		}



6 : add_history
	#include <readline/readline.h>
	#include <readline/history.h>

	void add_history(const char *line);

	ajoute une ligne de texte a l'historique de readline.

		ex :
		input = readline("Entrez une commande: ");
    
		if (input)
		{
			add_history(input);// Ajouter la commande à l'historique
			printf("Commande ajoutée à l'historique: %s\n", input);
			
			free(input);
		}



7 : printf
	pas besoin d'expliquer.

8 : malloc
	pas besoin d'expliquer.

 : free
	pas besoin d'expliquer.

10 : write
	pas besoin d'expliquer.

11 : access
	#include <unistd.h>

	int access(const char *pathname, int mode);

	permet de vérifier l'accessibilité d'un fichier ou d'un répertoire
	spécifié par pathname en fonction des droits d'accès spécifiés par mode.

	Les valeurs possibles pour mode sont :
		R_OK : pour vérifier si le fichier peut être lu.
		W_OK : pour vérifier si le fichier peut être écrit.
		X_OK : pour vérifier si le fichier peut être exécuté.
		F_OK : pour vérifier l'existence du fichier

		ex :
		int main()
		{
			const char *filename = "test.txt";

			// Vérifier si le fichier existe
			if (access(filename, F_OK) == -1)
		{
				perror("Erreur : fichier non trouvé");
				return 1;
			}

			// Vérifier si le fichier peut être lu
			if (access(filename, R_OK) == -1)
		{
				perror("Erreur : fichier non lisible");
			} else
		{
				printf("Le fichier peut être lu.\n");
			}

			// Vérifier si le fichier peut être écrit
			if (access(filename, W_OK) == -1)
		{
				perror("Erreur : fichier non modifiable");
			} else
		{
				printf("Le fichier peut être écrit.\n");
			}

			// Vérifier si le fichier peut être exécuté
			if (access(filename, X_OK) == -1)
		{
				perror("Erreur : fichier non exécutable");
			} else
		{
				printf("Le fichier peut être exécuté.\n");
			}

			return 0;
		}



12 : open
	pas besoin d'expliquer.

13 : read
	pas besoin d'expliquer.

14 : close
	pas besoin d'expliquer.

15 : fork
	#include <unistd.h>

	pid_t fork(void);

	creer un processus enfant du programme parent.

		ex :
		int main()
		{
			pid_t pid = fork();  // Création du processus enfant
			if (pid < 0)
				return (perror("Erreur fork"), 1);// Si fork échoue
			if (pid == 0)// Code exécuté par l'enfant
				printf("Je suis le processus enfant avec PID %d\n", getpid());
			else// Code exécuté par le parent
				printf("Je suis le processus parent avec PID %d, mon enfant a le PID %d\n", getpid(), pid);
			return 0;
		}



16 : wait
	#include <sys/types.h>
	#include <sys/wait.h>
	#include <unistd.h>

	pid_t wait(int *status);

	fait attendre le processus appelant (généralement le processus parent)
	jusqu'à ce qu'un de ses enfants termine son exécution. Si plusieurs
	processus enfants se terminent en même temps, wait retournera l'un d'eux.

		ex :
		int main()
		{
			pid_t pid = fork();  // Création du processus enfant
			if (pid < 0)
				return (perror("Erreur fork"), 1);// Si fork échoue
			if (pid == 0)
				printf("Je suis l'enfant, mon PID est %d\n", getpid());
			else
			{
				// Code exécuté par le parent
				int status;
				pid_t child_pid = wait(&status);  // Le parent attend que l'enfant se termine

				if (child_pid > 0)
		{
					if (WIFEXITED(status))
		{
						printf("Le processus enfant %d a terminé avec le code de sortie %d\n", child_pid, WEXITSTATUS(status));
					} else
		{
						printf("Le processus enfant %d a terminé de manière anormale\n", child_pid);
					}
				}
			}
		}



17 : waitpid
	#include <sys/types.h>
	#include <sys/wait.h>
	#include <unistd.h>

	pid_t waitpid(pid_t pid, int *status, int options);

	attend la fin d'un processus enfant spécifique, identifié par son PID.
	Elle permet aussi de spécifier des options de comportement de l'attente.

	pid : Si pid est positif, waitpid attend que le processus ayant ce PID
	se termine.

	Si pid == -1, waitpid attend la fin de n'importe quel processus
	enfant (comportement similaire à wait).
	Si pid == 0, waitpid attend la fin de n'importe quel processus
	enfant dont le groupe de processus est le même que celui du parent.
	Si pid est négatif, waitpid attend la fin de n'importe quel processus
	enfant dont le groupe de processus est le même que -pid.

		ex :
		int main()
		{
			pid_t pid = fork();  // Création du processus enfant
			if (pid < 0)
				return (perror("Erreur fork"), 1);// Si fork échoue
			if (pid == 0)
				printf("Je suis l'enfant, mon PID est %d\n", getpid());
			else
			{
				// Code exécuté par le parent
				int status;
				pid_t child_pid = waitpid(pid, &status, 0);   // Le parent attend spécifiquement cet enfant

				if (child_pid > 0)
		{
					if (WIFEXITED(status))
		{
						printf("Le processus enfant %d a terminé avec le code de sortie %d\n", child_pid, WEXITSTATUS(status));
					} else
		{
						printf("Le processus enfant %d a terminé de manière anormale\n", child_pid);
					}
				}
			}
		}



18 : wait3
	#include <sys/types.h>
	#include <sys/wait.h>
	#include <sys/resource.h>
	#include <unistd.h>

	pid_t wait3(int *status, int options, struct rusage *usage);

	attend la fin d'un processus enfant et permet de récupérer des
	informations sur l'utilisation des ressources via la structure rusage.
	Elle fonctionne de manière similaire à waitpid, mais en plus, elle
	remplit la structure rusage avec des informations sur les ressources
	utilisées par l'enfant (temps CPU, mémoire, etc.).

	* status : Un pointeur vers un entier où l'état de l'enfant est stocké.
	On peut utiliser des macros comme WIFEXITED(status) ou WEXITSTATUS(status)
	pour examiner cet état.
	* options : Permet de spécifier des options, comme WNOHANG pour éviter de
	bloquer le parent si aucun processus enfant n'est terminé.
	* usage : Un pointeur vers une structure rusage dans laquelle seront
	stockées des informations sur l'utilisation des ressources par l'enfant
	(temps CPU, nombre de pages mémoires, etc.).

	Valeur de retour :

	Si wait3 réussit, elle retourne le PID de l'enfant qui a terminé.
	Si un erreur se produit, elle retourne -1 et définit errno.

		ex :
		int main()
		{
			pid_t pid = fork();  // Créer un processus enfant

			if (pid < 0)
			{
				// Gestion d'erreur de fork
				perror("Erreur fork");
				return 1;
			}

			if (pid == 0)
			{
				// Code exécuté par l'enfant
				printf("Je suis l'enfant, mon PID est %d\n", getpid());
				for (int i = 0; i < 1000000; i++);  // Faire un peu de travail pour consommer du temps CPU
				exit(42);  // L'enfant termine avec un code de sortie
			}
			else
			{
				// Code exécuté par le parent
				int status;
				struct rusage usage;
				
				pid_t child_pid = wait3(&status, 0, &usage);  // Le parent attend spécifiquement cet enfant et récupère des infos sur l'utilisation des ressources

				if (child_pid > 0)
				{
					if (WIFEXITED(status))
					{
						printf("Le processus enfant %d a terminé avec le code de sortie %d\n", child_pid, WEXITSTATUS(status));
						printf("Temps utilisateur : %ld.%06ld secondes\n", usage.ru_utime.tv_sec, usage.ru_utime.tv_usec);
						printf("Temps système : %ld.%06ld secondes\n", usage.ru_stime.tv_sec, usage.ru_stime.tv_usec);
					}
					else
						printf("Le processus enfant %d a terminé de manière anormale\n", child_pid);
				}
				else
					perror("Erreur wait3");
			}

			return 0;
		}



19 : wait4
	#include <sys/types.h>
	#include <sys/wait.h>
	#include <sys/resource.h>
	#include <unistd.h>

	pid_t wait4(pid_t pid, int *status, int options, struct rusage *usage);

	fonctionne de manière similaire à wait3, mais elle offre plus de flexibilité
	en permettant de spécifier un processus particulier.

	* pid : Le PID de l'enfant à attendre. Si pid est -1, wait4 attend n'importe
	quel enfant. Si pid est 0, wait4 attend n'importe quel enfant du même groupe
	de processus que le parent. Si pid est positif, wait4 attend spécifiquement
	ce processus enfant.
	* status : Un pointeur vers un entier qui recevra l'état de l'enfant (terminé
	ou arrêté). Des macros comme WIFEXITED(status) et WEXITSTATUS(status) peuvent
	être utilisées pour interpréter cet état.
	* options : Permet de spécifier des options, comme WNOHANG pour éviter de
	bloquer si l'enfant n'est pas encore terminé, ou WUNTRACED pour aussi
	attendre les enfants arrêtés.
	* usage : Un pointeur vers une structure rusage dans laquelle seront
	stockées des informations sur l'utilisation des ressources par l'enfant
	(temps CPU, mémoire, etc.).

	Valeur de retour :
		Si wait4 réussit, elle retourne le PID de l'enfant qui a terminé.
		Si un erreur se produit, elle retourne -1 et définit errno.

		ex :
		int main()
		{
			pid_t pid = fork();  // Créer un processus enfant

			if (pid < 0)
			{
				// Gestion d'erreur de fork
				perror("Erreur fork");
				return 1;
			}

			if (pid == 0)
			{
				// Code exécuté par l'enfant
				printf("Je suis l'enfant, mon PID est %d\n", getpid());
				for (int i = 0; i < 1000000; i++);  // Faire un peu de travail pour consommer du temps CPU
				exit(42);  // L'enfant termine avec un code de sortie
			}
			else
			{
				// Code exécuté par le parent
				int status;
				struct rusage usage;
				
				pid_t child_pid = wait4(pid, &status, 0, &usage);  // Le parent attend spécifiquement cet enfant et récupère des infos sur l'utilisation des ressources

				if (child_pid > 0)
				{
					if (WIFEXITED(status))
					{
						printf("Le processus enfant %d a terminé avec le code de sortie %d\n", child_pid, WEXITSTATUS(status));
						printf("Temps utilisateur : %ld.%06ld secondes\n", usage.ru_utime.tv_sec, usage.ru_utime.tv_usec);
						printf("Temps système : %ld.%06ld secondes\n", usage.ru_stime.tv_sec, usage.ru_stime.tv_usec);
					}
					else
						printf("Le processus enfant %d a terminé de manière anormale\n", child_pid);
				}
				else
					perror("Erreur wait3");
			}

			return 0;
		}



20 : signal
	#include <signal.h>

	typedef void (*sighandler_t)(int);

	sighandler_t signal(int sig, sighandler_t handler);

	permet de définir un gestionnaire pour un signal spécifique.
	Lorsqu'un signal est reçu, le gestionnaire spécifié est exécuté.

	* sig : Le signal que l'on souhaite capturer (par exemple, SIGINT,
	SIGTERM, etc.). Le signal SIGKILL ne peut pas être capturé, ignoré
	ou modifié.
	* handler : Un pointeur vers une fonction qui sera exécutée lorsque
	le signal spécifié est reçu. Cette fonction prend un seul argument,
	l'identifiant du signal, et retourne void.
		Si handler est SIG_IGN, cela signifie que le signal sera ignoré.
		Si handler est SIG_DFL, cela signifie que le comportement par défaut
		du signal sera rétabli.

	Valeur de retour :
	En cas de succès, signal retourne l'ancien gestionnaire de signal.
	En cas d'erreur, elle retourne SIG_ERR et définit errno.

		ex :
		void handler_SIGINT(int sig)
		{
			printf("\nLe signal SIGINT a été capté (Ctrl+C).\n");
			// On peut choisir de quitter le programme après avoir capté le signal
			exit(0);  // Quitte le programme
		}

		int main()
		{
			// Définir le gestionnaire pour SIGINT
			if (signal(SIGINT, handler_SIGINT) == SIG_ERR)
			{
				perror("Erreur lors de la définition du gestionnaire pour SIGINT");
				return 1;
			}

			printf("Le programme est en cours d'exécution.\n");
			printf("Appuyez sur Ctrl+C pour tester le gestionnaire de signal.\n");

			// Programme qui attend un signal
			while (1)
				sleep(1);  // Le programme attend sans rien faire, il sera réveillé par le signal

			return 0;
		}



21 : sigaction
	#include <signal.h>

	int sigaction(int sig, const struct sigaction *act, struct sigaction *oldact);

	permet de définir l'action à prendre lors de la réception d'un signal
	spécifique. Contrairement à signal, sigaction offre un contrôle plus
	fin et permet de définir des options supplémentaires.

	* sig : Le signal pour lequel définir l'action (par exemple, SIGINT,
	SIGTERM, etc.).
	* act : Un pointeur vers une structure sigaction qui contient
	l'action à prendre pour le signal.
	* oldact : Un pointeur vers une structure sigaction où sera stockée
	l'ancienne action associée à ce signal (si non nul). Cela permet
	de restaurer l'action précédente si nécessaire.

	La structure sigaction contient les éléments suivants :

	struct sigaction
	{
		void (*sa_handler)(int);        // Gestionnaire de signal
		void (*sa_sigaction)(int, siginfo_t *, void *); // Gestionnaire de signal plus détaillé (utilisé pour des signaux comme SIGSEGV)
		sigset_t sa_mask;               // Masque de signaux à bloquer pendant l'exécution du gestionnaire
		int sa_flags;                   // Options pour l'action
		void (*sa_restorer)(void);      // Réservé pour une utilisation interne
	};

	* sa_handler : Un pointeur vers la fonction qui gère le signal, ou un des
	mots-clés SIG_IGN (ignorer) ou SIG_DFL (comportement par défaut).
	* sa_mask : Définit les signaux à bloquer pendant l'exécution du gestionnaire
	de signal.
	* sa_flags : Des options supplémentaires, par exemple :
	* SA_RESTART : Redémarre les appels systèmes interrompus par le signal.
	* SA_SIGINFO : Utilise sa_sigaction au lieu de sa_handler pour gérer des
	signaux plus complexes, permettant d'obtenir plus d'informations sur le
	signal (par exemple, siginfo_t).

	Valeur de retour :
		En cas de succès, sigaction retourne 0.
		En cas d'erreur, elle retourne -1 et définit errno.

		ex :
		void handler_SIGINT(int sig)
		{
			printf("\nLe signal SIGINT a été capté (Ctrl+C).\n");
			// Le programme peut choisir de quitter après avoir capté le signal
			exit(0);  // Quitte le programme
		}

		int main()
		{
			struct sigaction sa;

			// Définir le gestionnaire pour SIGINT
			sa.sa_handler = handler_SIGINT;   // Définir le gestionnaire de signal
			sa.sa_flags = 0;                   // Pas de flags
			sigemptyset(&sa.sa_mask);          // Aucun signal à bloquer pendant l'exécution du gestionnaire

			// Installer le gestionnaire pour SIGINT
			if (sigaction(SIGINT, &sa, NULL) == -1)
			{
				perror("Erreur sigaction");
				return 1;
			}

			printf("Le programme est en cours d'exécution.\n");
			printf("Appuyez sur Ctrl+C pour tester le gestionnaire de signal.\n");

			// Programme qui attend un signal
			while (1)
			{
				sleep(1);  // Le programme attend sans rien faire, il sera réveillé par le signal
			}

			return 0;
		}



22 : sigemptyset
	#include <signal.h>

	int sigemptyset(sigset_t *set);

	initialise l'ensemble de signaux pointé par set à un ensemble vide,
	c'est-à-dire qu'aucun signal n'est inclus dans cet ensemble.

	set : Un pointeur vers un objet de type sigset_t, qui est utilisé
	pour contenir des ensembles de signaux.

	Valeur de retour :
		En cas de succès, sigemptyset retourne 0.
		En cas d'erreur, elle retourne -1 et définit errno.

		ex :
		int main()
		{
			sigset_t set;

			// Initialiser l'ensemble de signaux à vide (aucun signal bloqué)
			if (sigemptyset(&set) == -1)
				return (perror("sigemptyset"), 1);

			// Afficher l'état initial de l'ensemble de signaux
			printf("Ensemble de signaux vide créé.\n");

			// Exemple : On bloque le signal SIGINT
			if (sigaddset(&set, SIGINT) == -1)
				return (perror("sigaddset"), 1);

			// Appliquer l'ensemble de signaux pour bloquer SIGINT
			if (sigprocmask(SIG_BLOCK, &set, NULL) == -1)
				return (perror("sigprocmask"), 1);

			// Attendre un signal pendant 10 secondes
			printf("SIGINT est bloqué. Attente pendant 10 secondes...\n");
			sleep(10);

			// Débloquer les signaux
			if (sigprocmask(SIG_UNBLOCK, &set, NULL) == -1)
				return (perror("sigprocmask"), 1);

			printf("SIGINT est maintenant débloqué.\n");

			return 0;
		}



23 : sigaddset
	#include <signal.h>

	int sigaddset(sigset_t *set, int sig);

	ajoute le signal sig à l'ensemble de signaux set.

	* set : Un pointeur vers un objet de type sigset_t, qui est utilisé
	pour contenir des ensembles de signaux.
	* sig : Le signal à ajouter à l'ensemble. Cela peut être un signal
	comme SIGINT, SIGTERM, etc.
	
	Valeur de retour :
		En cas de succès, sigaddset retourne 0.
		En cas d'erreur, elle retourne -1 et définit errno.


		ex :
		int main()
		{
			sigset_t set;

			// Initialiser l'ensemble de signaux à vide (aucun signal bloqué)
			if (sigemptyset(&set) == -1)
				return (perror("sigemptyset"), 1);

			// Ajouter le signal SIGINT (Ctrl+C) à l'ensemble
			if (sigaddset(&set, SIGINT) == -1)
				return (perror("sigaddset"), 1);

			// Appliquer l'ensemble de signaux pour bloquer SIGINT
			if (sigprocmask(SIG_BLOCK, &set, NULL) == -1)
				return (perror("sigprocmask"), 1);

			// Attendre un signal pendant 10 secondes
			printf("SIGINT est bloqué. vous pouvez appuyer sur Ctrl+C, mais le signal sera ignoré pendant 10 secondes...\n");
			sleep(10);

			// Débloquer les signaux
			if (sigprocmask(SIG_UNBLOCK, &set, NULL) == -1)
				return (perror("sigprocmask"), 1);

			printf("SIGINT est maintenant débloqué.\n");

			return 0;
		}



24 : kill
	#include <signal.h>

	int kill(pid_t pid, int sig);

	permet d'envoyer un signal à un ou plusieurs processus.

	pid : L'identifiant du processus cible.
		* Si pid > 0, le signal est envoyé au processus avec l'identifiant
		de processus pid.
		* Si pid == 0, le signal est envoyé à tous les processus dans le même
		groupe de processus que le processus appelant.
		* Si pid == -1, le signal est envoyé à tous les processus dont l'appelant
		a les droits d'envoyer un signal.
		* Si pid < -1, le signal est envoyé à tous les processus dans le groupe

	de processus avec l'identifiant pid (en utilisant la valeur absolue de pid).
	sig : Le signal à envoyer. Cela peut être un signal standard comme SIGINT,
	SIGTERM, SIGKILL, etc.

	Valeur de retour :
		En cas de succès, kill retourne 0.
		En cas d'erreur, elle retourne -1 et définit errno.

		ex :
		int main()
		{
			pid_t pid;
			pid = fork();  // Créer un processus fils

			if (pid < 0)
				return (perror("fork"), 1);
			if (pid == 0)
			{
				printf("Le processus fils est en cours d'exécution, pid = %d\n", getpid());
				sleep(10);  // Le processus fils attend pendant 10 secondes avant de se terminer
				printf("Le processus fils se termine\n");
				exit(0);
			}
			else
			{
				printf("Le processus père envoie un signal SIGTERM au processus fils (pid = %d)\n", pid);
				sleep(3);  // Le père attend 3 secondes avant d'envoyer le signal
				if (kill(pid, SIGTERM) == -1)// Envoi du signal SIGTERM
					return (perror("kill"), 1);
				printf("Signal SIGTERM envoyé au processus fils\n");
			}

			return 0;
		}



25 : exit
	#include <stdlib.h>

	void exit(int status);

	termine le programme en cours d'exécution. Avant de quitter, exit
	effectue plusieurs opérations de nettoyage, telles que la fermeture
	des fichiers ouverts et l'appel des gestionnaires de termination enregistrés
	(via atexit).

	status : Le code de sortie du programme. Ce code sera renvoyé à
	l'environnement d'exécution.
	Par convention :
		Un code de sortie égal à 0 signifie que le programme s'est exécuté
		correctement.
		Un code de sortie différent de 0 indique une erreur ou une fin
		anormale du programme.

		ex :
		int main()
		{
			int val;

			printf("Entrez un nombre entier positif : ");
			if (scanf("%d", &val) != 1)
			{
				// Si l'entrée n'est pas un entier, on termine le programme avec un code d'erreur
				printf("Erreur : entrée invalide.\n");
				exit(1);  // Code de sortie 1 pour signaler une erreur
			}

			if (val < 0)
			{
				// Si la valeur est négative, on termine également avec un code d'erreur
				printf("Erreur : le nombre doit être positif.\n");
				exit(2);  // Code de sortie 2 pour signaler une erreur spécifique
			}

			printf("Vous avez entré le nombre : %d\n", val);
			
			// Terminer le programme avec succès
			exit(0);  // Code de sortie 0 pour signaler une exécution réussie
		}



26 : getcwd
	#include <unistd.h>

	char *getcwd(char *buf, size_t size);

	retourne le chemin absolu du répertoire de travail actuel du processus.

	* buf : Un pointeur vers un tampon où le chemin sera stocké. Si buf est
	NULL, la fonction alloue un tampon pour le chemin.
	* size : La taille du tampon. Elle doit être suffisante pour contenir
	le chemin, y compris le caractère nul de fin de chaîne (\0).
	
	Si NULL est passé a buf, getcwd allouera dynamiquement un tampon pour
	contenir le chemin. Dans ce cas, la mémoire allouée devra etre libérée
	après utilisation.
	
	Si le répertoire de travail actuel ne tient pas dans le tampon,
	getcwd renvoie NULL et définit errno sur ERANGE.

	Valeur de retour :
		En cas de succès, getcwd retourne un pointeur vers buf, qui
		contient le chemin du répertoire actuel.
		En cas d'échec, elle retourne NULL et définit errno.

		ex :
		int main()
		{
			char *cwd;
			char buffer[1024];

			// Utiliser getcwd pour obtenir le répertoire de travail actuel
			cwd = getcwd(buffer, sizeof(buffer));

			if (cwd == NULL)// Si une erreur se produit, afficher un message d'erreur
				return (perror("getcwd"), 1);

			printf("Le répertoire de travail actuel est : %s\n", cwd);
			return 0;
		}



27 : chdir
	#include <unistd.h>

	int chdir(const char *path);

	change le répertoire de travail courant du processus appelant pour celui
	spécifié par path.

	path : Le chemin du répertoire à définir comme répertoire de travail
	courant. Il peut être relatif ou absolu.
		* Si path est un chemin absolu (commence par /), il spécifie un
		emplacement exact dans le système de fichiers.
		* Si path est un chemin relatif (sans / au début), il est interprété
		par rapport au répertoire courant avant l'appel de chdir.

	Valeur de retour :
		En cas de succès, chdir retourne 0.
		En cas d'erreur, elle retourne -1 et définit errno pour indiquer
		l'erreur. Les erreurs courantes incluent :
			ENOENT : Le répertoire spécifié n'existe pas.
			EACCES : Le processus n'a pas les permissions nécessaires pour
			accéder au répertoire.
			ENOTDIR : Le chemin spécifié n'est pas un répertoire.

		ex :
		int main()
		{
			char currentDir[1024];

			// Afficher le répertoire courant avant de changer
			if (getcwd(currentDir, sizeof(currentDir)) != NULL)
				printf("Répertoire actuel : %s\n", currentDir);
			else
				return (perror("getcwd"), 1);

			// Essayer de changer le répertoire de travail
			if (chdir("/tmp") == -1)// Si l'appel échoue, afficher un message d'erreur
				return (perror("chdir"), 1);

			// Afficher le répertoire courant après le changement
			if (getcwd(currentDir, sizeof(currentDir)) != NULL)
				printf("Nouveau répertoire de travail : %s\n", currentDir);
			else
				return (perror("getcwd"), 1);

			return 0;
		}



28 : stat
	#include <sys/stat.h>
	#include <unistd.h>

	int stat(const char *path, struct stat *buf);

	permet d'obtenir des informations sur un fichier ou un répertoire.
	Elle remplit une structure stat avec des informations sur le fichier
	spécifié par le chemin path.

	* path : Le chemin du fichier ou du répertoire pour lequel les informations
	doivent être récupérées.
	* buf : Un pointeur vers une structure stat qui sera remplie avec les
	informations du fichier.
	La structure stat contient diverses informations :
		st_dev : Identifiant du périphérique contenant le fichier
		st_ino : Numéro d'inode du fichier
		st_mode : Mode du fichier (type et permissions)
		st_nlink : Nombre de liens physiques vers le fichier
		st_uid : Identifiant de l'utilisateur propriétaire du fichier
		st_gid : Identifiant du groupe propriétaire du fichier
		st_rdev : Identifiant du périphérique (si c'est un fichier spécial)
		st_size : Taille du fichier en octets
		st_blksize : Taille de bloc optimale pour les opérations d'E/S
		st_blocks : Nombre de blocs alloués pour le fichier
		st_atime : Dernier accès au fichier
		st_mtime : Dernière modification du fichier
		st_ctime : Dernier changement d'état du fichier

	Valeur de retour :
		En cas de succès, stat retourne 0.
		En cas d'erreur, elle retourne -1 et définit errno pour indiquer
		l'erreur (par exemple, si le fichier n'existe pas).

		ex :
		int main()
		{
			const char *file_path = "example.txt";
			struct stat file_info;

			// Appeler stat pour obtenir des informations sur le fichier
			if (stat(file_path, &file_info) == -1)
				return (perror("stat"), 1);

			// Afficher certaines informations sur le fichier
			printf("Informations sur le fichier '%s':\n", file_path);
			printf("Taille du fichier : %ld octets\n", file_info.st_size);
			printf("Permissions : %o\n", file_info.st_mode & 0777);  // Afficher les permissions en octal
			printf("Numéro d'inode : %ld\n", file_info.st_ino);
			printf("Dernière modification : %ld secondes depuis l'époque Unix\n", file_info.st_mtime);

			return 0;
		}



29 : lstat
	#include <sys/stat.h>
	#include <unistd.h>

	int lstat(const char *path, struct stat *buf);

	fonctionne de la même manière que stat, à l'exception qu'elle ne suit
	pas les liens symboliques.

	* path : Le chemin du fichier ou du répertoire pour lequel obtenir des
	informations.
	* buf : Un pointeur vers une structure stat qui sera remplie avec les
	informations sur le fichier.
	Si le chemin correspond à un lien symbolique, lstat retourne des
	informations sur le lien lui-même et non sur le fichier cible du lien.

	Valeur de retour :
		En cas de succès, lstat retourne 0.
		En cas d'échec, lstat retourne -1 et définit errno pour indiquer
		l'erreur.

		ex :
		int main()
		{
			const char *path = "mon_lien_symbolique";
			struct stat file_info;

			// Utiliser lstat pour obtenir des informations sur le fichier ou le lien
			if (lstat(path, &file_info) == -1)
				return (perror("lstat"), 1);

			// Vérifier si c'est un lien symbolique
			if (S_ISLNK(file_info.st_mode))
				printf("'%s' est un lien symbolique.\n", path);
			else
				printf("'%s' n'est pas un lien symbolique.\n", path);

			// Afficher des informations sur le fichier ou le lien
			printf("Numéro d'inode : %ld\n", file_info.st_ino);
			printf("Taille du fichier : %ld octets\n", file_info.st_size);
			printf("Permissions : %o\n", file_info.st_mode & 0777);  // Masquer les bits de type
			printf("Dernière modification : %ld secondes depuis l'époque Unix\n", file_info.st_mtime);

			return 0;
		}



30 : fstat
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>
	#include <unistd.h>

	int fstat(int fd, struct stat *statbuf);

	permet de récupérer les informations sur un fichier ouvert, à partir de son
	descripteur de fichier. Elle remplit une structure stat avec des informations
	sur le fichier, telles que son type, sa taille, ses permissions, son propriétaire,
	et d'autres attributs.

	* fd : le descripteur de fichier du fichier ouvert (par exemple, renvoyé par open()).
	* statbuf : un pointeur vers une structure stat qui sera remplie avec les informations
	du fichier.

	Retour :
	En cas de succès, fstat() retourne 0.
	En cas d'erreur, elle retourne -1 et définit errno.

		ex :
		int main()
		{
			int fd = open("exemple.txt", O_RDONLY);
			
			if (fd == -1)
				return (perror("Erreur d'ouverture du fichier"), 1);

			struct stat statbuf;
			if (fstat(fd, &statbuf) == -1)
				return (perror("Erreur fstat"), close(fd), 1);

			printf("Informations sur le fichier :\n");
			printf("Taille : %ld octets\n", statbuf.st_size);
			printf("Permissions : %o\n", statbuf.st_mode & 0777);
			printf("Dernier accès : %ld\n", statbuf.st_atime);
			printf("Dernière modification : %ld\n", statbuf.st_mtime);
			printf("Dernier changement : %ld\n", statbuf.st_ctime);

			close(fd);
			return 0;
		}



31 : unlink
	#include <unistd.h>

	int unlink(const char *pathname);

	supprime un fichier du système de fichiers. Cela signifie que le fichier n'est
	plus accessible, mais il reste physiquement sur le disque tant qu'il n'a pas été
	libéré par le système, c'est-à-dire que les blocs de données ne sont pas encore
	réutilisés. Si le fichier est toujours ouvert par un processus, il restera accessible
	jusqu'à ce que le dernier descripteur de fichier soit fermé.

	pathname : le chemin absolu ou relatif vers le fichier à supprimer.

	Retour :
		En cas de succès, unlink() retourne 0.
		En cas d'erreur, elle retourne -1 et définit errno.

		ex :
		int main()
		{
			const char *filename = "fichier_a_supprimer.txt";

			// Suppression du fichier
			if (unlink(filename) == -1)
				return (perror("Erreur lors de la suppression du fichier"), 1);

			printf("Le fichier '%s' a été supprimé avec succès.\n", filename);
			return 0;
		}



32 : execve
	#include <unistd.h>

	int execve(const char *pathname, char *const argv[], char *const envp[]);

	permet de lancer un programme à partir du processus actuel. Elle remplace le
	processus appelant par un nouveau programme, en chargeant ce dernier dans
	l'espace mémoire du processus. Elle est généralement utilisée pour exécuter
	des programmes externes.

	* pathname : le chemin vers le programme à exécuter.
	* argv : un tableau de chaînes de caractères représentant les arguments passés
		au programme. Le premier élément de argv est traditionnellement le nom du programme.
	* envp : un tableau de chaînes de caractères représentant les variables
		d'environnement à passer au programme (habituellement environ ou NULL).
	
	Retour :
		Si la fonction réussit, elle ne retourne jamais, car le processus appelant est
		remplacé par le nouveau programme.
		En cas d'erreur, elle retourne -1 et définit errno.

		ex :
		int main()
		{
			// Programme à exécuter (ls)
			const char *program = "/bin/ls";
			
			// Arguments à passer au programme
			char *const argv[] = {
				"ls",    // Nom du programme (traditionnellement le nom du programme)
				"-l",    // Argument pour la commande
				NULL     // Liste terminée par NULL
			};

			// Variables d'environnement (on passe NULL pour les valeurs par défaut)
			char *const envp[] = { NULL };// Liste terminée par NULL

			// Exécution de la commande "ls -l"
			if (execve(program, argv, envp) == -1)
				return (perror("Erreur execve"), 1);

			return 0; // Ce code ne sera jamais atteint si execve réussit
		}



33 : dup
	#include <unistd.h>

	int dup(int oldfd);

	crée une copie d'un descripteur de fichier. Le descripteur de fichier retourné
	fait référence au même fichier que l'original. Cela signifie que toute opération
	d'entrée/sortie sur le descripteur copié affectera également le descripteur d'origine.

	Fonctionnement :
		Le descripteur de fichier retourné est l'un des plus petits numéros de
		descripteur de fichier disponibles.
		Si l'argument oldfd fait référence à un fichier déjà ouvert, le nouveau
		descripteur pointe également vers ce fichier.
		La fermeture de l'un des descripteurs ne ferme pas l'autre, sauf si un
		seul descripteur fait encore référence au fichier.

	Paramètres :
		oldfd : le descripteur de fichier à dupliquer.

	Retour :
		En cas de succès, dup() retourne un nouveau descripteur de fichier, qui est
		une copie de oldfd.
		En cas d'erreur, elle retourne -1 et définit errno.

		ex :
		int main()
		{
			// Ouvrir un fichier pour écrire
			int file = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
			
			if (file == -1)
				return (perror("Erreur d'ouverture du fichier"), 1);

			// Dupliquer le descripteur de fichier (stdout -> output.txt)
			int newfd = dup(file);
			
			if (newfd == -1)
				return (perror("Erreur lors de la duplication du descripteur"), close(file), 1);

			// Fermer le descripteur original
			close(file);

			// Maintenant, toutes les écritures sur stdout iront dans "output.txt"
			write(newfd, "Ceci est écrit dans le fichier output.txt\n", 41);

			// Fermer le descripteur dupliqué
			close(newfd);

			return 0;
		}



34 : dup2
	#include <unistd.h>

	int dup2(int oldfd, int newfd);

	permet de dupliquer un descripteur de fichier en le remplaçant par un autre
	descripteur spécifique. Contrairement à dup(), où le descripteur retourné est
	le plus bas disponible, dup2() vous permet de spécifier directement le descripteur
	cible, ce qui permet de rediriger plus précisément les flux.

	Fonctionnement :
		Si oldfd est un descripteur valide, dup2() crée une copie de celui-ci dans newfd.
		Si newfd est déjà ouvert, il est d'abord fermé avant d'être dupliqué.
		newfd devient donc un duplicata de oldfd, pointant vers le même fichier ou flux,
		et toutes les opérations sur newfd affecteront oldfd et vice versa.
		Si oldfd est égal à newfd, la fonction ne fait rien et retourne simplement newfd.

	Paramètres :
		oldfd : le descripteur de fichier à dupliquer.
		newfd : le descripteur de fichier cible qui sera utilisé pour la duplication.

	Retour :
		En cas de succès, dup2() retourne le nouveau descripteur de fichier (newfd).
		En cas d'erreur, elle retourne -1 et définit errno.

		ex :
		int main()
		{
			// Ouvrir un fichier pour écrire
			int file = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
			
			if (file == -1)
				return (perror("Erreur d'ouverture du fichier"), 1);

			// Dupliquer le descripteur de fichier pour rediriger stdout vers le fichier
			if (dup2(file, STDOUT_FILENO) == -1)
				return (perror("Erreur lors de la redirection de stdout"), close(file), 1);

			// Fermer le descripteur original car il n'est plus nécessaire
			close(file);

			// La sortie standard est maintenant redirigée vers "output.txt"
			printf("Ceci est écrit dans le fichier output.txt\n");

			return 0;
		}



35 : pipe
	#include <unistd.h>

	int pipe(int pipefd[2]);

	permet de créer un tube (ou pipe), c'est-à-dire un mécanisme de communication
	inter-processus. Elle crée un canal unidirectionnel qui permet à un processus
	d'écrire dans un descripteur de fichier et à un autre processus de lire à partir
	de ce même canal.

	Fonctionnement :
		Le premier descripteur (pipefd[0]) est utilisé pour la lecture depuis le tube,
		et le second (pipefd[1]) est utilisé pour l'écriture.
		La communication dans un tube est unidirectionnelle : une application écrit
		dans un tube, tandis qu'une autre le lit.
		Si un processus ferme le descripteur de lecture ou d'écriture, cela n'affecte
		pas les autres descripteurs du tube.

	Paramètres :
		pipefd : un tableau de deux entiers. pipefd[0] est le descripteur de lecture
		du pipe, et pipefd[1] est le descripteur d'écriture. Ces descripteurs permettent
		à un processus de lire à partir de pipefd[0] et d'écrire dans pipefd[1].

	Retour :
		En cas de succès, pipe() retourne 0.
		En cas d'erreur, elle retourne -1 et définit errno.

		ex :
		int main()
		{
			int pipefd[2];
			pid_t pid;
			char buf[100];

			// Créer un pipe
			if (pipe(pipefd) == -1)
				return (perror("pipe"), 1);

			// Créer un processus enfant
			pid = fork();

			if (pid == -1)
				return (perror("fork"), 1);

			if (pid == 0)
			{  // Processus enfant
				// Fermer le descripteur de lecture
				close(pipefd[0]);

				// Écrire dans le pipe
				const char *msg = "Message du processus enfant\n";
				write(pipefd[1], msg, strlen(msg));

				// Fermer le descripteur d'écriture
				close(pipefd[1]);
			}
			else
			{  // Processus parent
				// Fermer le descripteur d'écriture
				close(pipefd[1]);

				// Lire depuis le pipe
				read(pipefd[0], buf, sizeof(buf));
				printf("Le parent a lu : %s", buf);

				// Fermer le descripteur de lecture
				close(pipefd[0]);

				// Attendre la fin du processus enfant
				wait(NULL);
			}

			return 0;
		}



36 : opendir
	#include <dirent.h>

	DIR *opendir(const char *dirname);

	ouvre un répertoire pour pouvoir le lire. Elle renvoie un pointeur vers un objet de
	type DIR, qui permet de parcourir le répertoire à l'aide de la fonction readdir().
	Une fois que le répertoire n'est plus nécessaire, il doit être fermé avec la fonction
	closedir().

	Fonctionnement :
		opendir() ouvre un répertoire et retourne un pointeur sur ce répertoire, prêt à
		être parcouru.
		Le répertoire peut ensuite être parcouru à l'aide de readdir(), et une fois
		terminé, il doit être fermé avec closedir().
		readdir() renvoie une structure dirent contenant des informations sur l'entrée
		du répertoire courant (nom de fichier, etc.).

	Paramètres :
		dirname : le chemin du répertoire à ouvrir. Si dirname est NULL ou invalide,
		la fonction échouera.
	
	Retour :
		Si la fonction réussit, elle retourne un pointeur vers un objet DIR (un
		descripteur de répertoire).
		En cas d'erreur, elle retourne NULL et définit errno.

		ex :
		int main()
		{
			const char *path = "."; // Chemin du répertoire courant

			// Ouvrir le répertoire
			DIR *dir = opendir(path);
			
			if (dir == NULL)
				return (perror("opendir"), 1);

			struct dirent *entry;
			// Lire les entrées du répertoire
			while ((entry = readdir(dir)) != NULL)
				printf("%s\n", entry->d_name);// Afficher le nom de chaque fichier/répertoir

			// Fermer le répertoire
			closedir(dir);
			
			return 0;
		}



37 : readdir
	#include <dirent.h>

	struct dirent *readdir(DIR *dirp);

	lit une entrée dans un répertoire ouvert. Elle permet de parcourir les fichiers
	et répertoires contenus dans un répertoire. Elle retourne un pointeur vers une
	structure dirent qui contient des informations sur l'entrée courante du répertoire.
	Cette fonction est utilisée après avoir ouvert un répertoire avec opendir().

	Fonctionnement :
		readdir() parcourt le répertoire pointé par dirp et retourne un pointeur vers
			la prochaine entrée.
		L'appel de readdir() après avoir atteint la fin du répertoire retourne NULL.
		Vous devez ouvrir le répertoire avec opendir() avant d'utiliser readdir(), et
			fermer le répertoire avec closedir() une fois le parcours terminé.

	Paramètres :
		dirp : un pointeur vers l'objet DIR représentant un répertoire ouvert par opendir().

	Retour :
		En cas de succès, readdir() retourne un pointeur vers une structure dirent
			qui contient les informations de l'entrée courante du répertoire.
		Si le répertoire a été complètement parcouru, readdir() retourne NULL.
		En cas d'erreur, readdir() retourne également NULL et errno est mis à jour
			pour indiquer l'erreur.

	La structure dirent contient les informations suivantes pour chaque entrée lue dans
	un répertoire :
		struct dirent
		{
			ino_t d_ino;            // Numéro d'inode
			off_t d_off;            // Offset du prochain fichier
			unsigned short d_reclen; // Longueur de l'entrée
			unsigned char d_type;    // Type de l'entrée (répertoire, fichier normal, etc.)
			char d_name[256];        // Nom de l'entrée (fichier, répertoire, etc.)
		};


		ex :
		int main()
		{
			const char *path = "."; // Chemin du répertoire courant

			// Ouvrir le répertoire
			DIR *dir = opendir(path);
			
			if (dir == NULL)
				return (perror("opendir"), 1);

			struct dirent *entry;
			// Lire les entrées du répertoire
			while ((entry = readdir(dir)) != NULL)
				printf("%s\n", entry->d_name);// Afficher le nom de chaque fichier/répertoir

			// Fermer le répertoire
			closedir(dir);
			
			return 0;
		}



38 : closedir
	#include <dirent.h>

	int closedir(DIR *dirp);

	La fonction closedir() est utilisée pour fermer un répertoire qui a été ouvert
	avec la fonction opendir(). Elle libère les ressources associées à l'objet DIR
	qui représente le répertoire. Après avoir fermé un répertoire avec closedir(),
	il n'est plus possible d'y accéder via les appels readdir().

	Fonctionnement :
		closedir() ferme le répertoire spécifié par dirp et libère toute ressource
			associée à cet objet DIR.
		Une fois qu'un répertoire a été fermé, l'objet DIR n'est plus valide, et
			vous ne pouvez plus utiliser readdir() avec ce pointeur.

	Paramètres :
		dirp : un pointeur vers un objet DIR représentant le répertoire à fermer.
		Cet objet doit avoir été retourné par opendir().
	
	Retour :
		Si la fonction réussit, closedir() retourne 0.
		En cas d'erreur, elle retourne -1 et définit errno pour indiquer l'erreur.

		ex :
		int main()
		{
			const char *path = "."; // Chemin du répertoire courant

			// Ouvrir le répertoire
			DIR *dir = opendir(path);
			
			if (dir == NULL)
				return (perror("opendir"), 1);

			struct dirent *entry;
			// Lire les entrées du répertoire
			while ((entry = readdir(dir)) != NULL)
				printf("%s\n", entry->d_name);// Afficher le nom de chaque fichier/répertoir

			// Fermer le répertoire
			closedir(dir);
			
			return 0;
		}



39 : strerror
	#include <string.h>

	char *strerror(int errnum);

	La fonction strerror() permet de retourner une chaîne de caractères décrivant
	l'erreur correspondant à une valeur d'errno. Cela permet d'afficher un message
	d'erreur lisible par l'utilisateur, correspondant à un code d'erreur particulier.

	Fonctionnement :
		strerror() permet de convertir un code d'erreur en une chaîne descriptive lisible,
			ce qui facilite le diagnostic des erreurs dans les programmes.
		La chaîne retournée est une description textuelle de l'erreur, qui est généralement
			un message standard du système d'exploitation.
	
	Paramètres :
		errnum : le code d'erreur dont on souhaite obtenir la description. Ce code
		d'erreur est généralement défini dans errno, qui est une variable globale
		définissant l'erreur la plus récente.

	Retour :
		strerror() retourne un pointeur vers une chaîne de caractères statique contenant
			la description de l'erreur correspondant à errnum.
		Si errnum n'est pas un code d'erreur valide, strerror() retourne une chaîne
			indiquant une erreur inconnue.

		ex :
		int main()
		{
			// Tentative d'ouverture d'un fichier inexistant
			FILE *file = fopen("fichier_inexistant.txt", "r");

			if (file == NULL)
				return (printf("Erreur : %s\n", strerror(errno)), 1);// Affichage du message d'erreur correspondant

			// Code d'exécution en cas de succès (non atteint ici)
			fclose(file);
			return 0;
		}



40 : perror
	#include <stdio.h>
	#include <errno.h>

	void perror(const char *str);

	affiche un message d'erreur sur stderr, en ajoutant une description de l'erreur
	à partir du code d'erreur global errno. Le message commence par une chaîne spécifiée
	par l'utilisateur, suivie d'un deux-points, d'un espace et de la description de
	l'erreur associée à la valeur de errno. Si errno est égal à zéro, perror() n'ajoute
	rien après le texte spécifié par l'utilisateur.

	Fonctionnement :
		perror() affiche un message d'erreur qui combine un texte fourni par l'utilisateur
			et la description de l'erreur correspondante à la valeur de errno.
		Cette fonction est souvent utilisée après une opération échouée, comme l'ouverture
			d'un fichier, la lecture ou l'écriture dans un fichier, ou encore l'allocation
			mémoire, pour donner des informations supplémentaires sur l'erreur.
	
	Paramètres :
		str : une chaîne de caractères que vous pouvez spécifier pour décrire le contexte
		de l'erreur (par exemple, une opération spécifique). Si cette chaîne est NULL ou
		vide, perror() utilise la chaîne "Error" par défaut.
	
	Retour :
		perror() n'a pas de valeur de retour. Elle écrit un message d'erreur sur stderr.

		ex :
		int main()
		{
			// Tentative d'ouverture d'un fichier inexistant
			FILE *file = fopen("fichier_inexistant.txt", "r");

			if (file == NULL)
				// Affichage de l'erreur avec perror
				return (perror("Erreur lors de l'ouverture du fichier"), 1);

			// Code d'exécution en cas de succès (non atteint ici)
			fclose(file);
			return 0;
		}



41 : isatty
	#include <unistd.h>

	int isatty(int fd);

	permet de vérifier si un descripteur de fichier est associé à un terminal.
	Elle est couramment utilisée pour savoir si le programme est exécuté dans un
	terminal interactif ou s'il redirige sa sortie vers un fichier ou un autre
	périphérique.



	Fonctionnement :
		isatty() vérifie si le fichier associé à fd est un terminal. Un terminal est
			généralement un périphérique spécial (comme /dev/tty sur les systèmes Unix)
			ou une interface qui permet une interaction avec l'utilisateur.
		Par exemple, isatty() peut être utilisée pour déterminer si la sortie standard
			(par défaut, STDOUT_FILENO) est un terminal ou si elle a été redirigée vers
			un fichier.
	
	Paramètres :
		fd : un descripteur de fichier (un entier) qui représente un fichier ouvert.
		Le descripteur de fichier est généralement obtenu après l'ouverture d'un fichier
		avec des fonctions comme open() ou fileno(), ou à partir des descripteurs standards
		comme STDIN_FILENO, STDOUT_FILENO, ou STDERR_FILENO.
	
	Retour :
		isatty() retourne 1 si le descripteur de fichier est associé à un terminal
			(par exemple, si fd pointe vers un terminal physique ou une session de terminal).
		Elle retourne 0 si le descripteur de fichier fd n'est pas associé à un terminal.
		En cas d'erreur (par exemple si fd n'est pas un descripteur valide), elle retourne
			-1 et définit errno pour indiquer l'erreur.

		ex :
		int main()
		{
			// Vérifier si la sortie standard (STDOUT_FILENO) est un terminal
			if (isatty(STDOUT_FILENO))
				printf("La sortie standard est un terminal.\n");
			else
				printf("La sortie standard n'est pas un terminal.\n");

			return 0;
		}



42 : ttyname
	#include <unistd.h>

	char *ttyname(int fd);

	retourne le nom du périphérique de terminal associé à un descripteur de fichier,
	typiquement un terminal standard comme /dev/tty ou /dev/pts/N. Cela permet de savoir
	à quel périphérique est connecté un terminal, par exemple si vous voulez connaître
	le nom de l'entrée ou de la sortie d'un terminal dans lequel un programme est exécuté.

	Fonctionnement :
		ttyname() est utilisé pour obtenir le nom du périphérique associé à un terminal.
		Le terminal est un périphérique spécial utilisé pour l'interaction avec
			l'utilisateur.
		Si le descripteur de fichier passé à ttyname() ne correspond pas à un terminal, par
			exemple si c'est un fichier ordinaire, la fonction échouera et retournera NULL.
	
	Paramètres :
		fd : le descripteur de fichier d'un terminal ouvert. En général, il s'agit de
		STDIN_FILENO, STDOUT_FILENO ou STDERR_FILENO, mais cela peut aussi être un autre
		descripteur de fichier d'un terminal.
	
	Retour :
		ttyname() retourne une chaîne de caractères contenant le nom du périphérique de
			terminal associé au descripteur de fichier fd. Par exemple, une valeur retournée
			pourrait être quelque chose comme "/dev/tty1", "/dev/pts/0", etc.
		Si fd ne correspond pas à un terminal ou si un problème survient, ttyname()
			retourne NULL et définit errno pour indiquer l'erreur.

		ex :
		int main()
		{
			// Obtenir le nom du terminal associé à la sortie standard
			char *tty = ttyname(STDOUT_FILENO);

			if (tty != NULL)
				printf("Le terminal associé à STDOUT est : %s\n", tty);
			else
				perror("Erreur lors de la récupération du nom du terminal");

			return 0;
		}



43 : ttyslot
	#include <unistd.h>

	int ttyslot(void);

	retourne le numéro de slot associé au terminal actuel. Un "slot" dans ce contexte
	fait référence à une position unique pour un terminal dans une table interne du
	système, généralement utilisée pour identifier de manière unique un terminal dans
	une session multi-utilisateur.

	Cette fonction est principalement utilisée dans les systèmes Unix, en particulier
	dans les systèmes qui gèrent plusieurs sessions de terminal, comme ceux utilisant
	/dev/ttyX pour les terminaux physiques et /dev/pts/X pour les terminaux pseudo-TTY
	(PTY).

	Fonctionnement :
		ttyslot() utilise des informations internes du système pour retourner le numéro
		de slot du terminal actuel. Cela peut être utilisé pour identifier de manière
		unique le terminal dans une session utilisateur.
		Le numéro de slot retourné est souvent utilisé dans les scripts ou les programmes
		qui souhaitent manipuler les sessions de terminal, particulièrement dans les
		systèmes à accès multi-utilisateurs ou multi-terminals.
	
	Retour :
		ttyslot() retourne le numéro de slot (un entier positif) associé au terminal
		actuel, ou -1 si aucune information n'est disponible, ce qui peut se produire
		si le terminal n'est pas bien identifié ou si l'environnement ne supporte pas
		cette fonctionnalité.

		ex :
		int main()
		{
			// Obtenir le numéro de slot du terminal actuel
			int slot = ttyslot();

			if (slot != -1)
				printf("Le numéro de slot de ce terminal est : %d\n", slot);
			else
				printf("Erreur : impossible d'obtenir le numéro de slot.\n");

			return 0;
		}



44 : ioctl
	#include <sys/ioctl.h>

	int ioctl(int fd, unsigned long request, ...);

	est utilisée pour manipuler des périphériques et des fichiers spéciaux en envoyant
	des commandes spécifiques à ces périphériques. Elle permet d'interagir avec des
	dispositifs en dehors du système de fichiers traditionnel, comme les périphériques
	de terminal, les sockets, ou les périphériques physiques.

	Fonctionnement :
		ioctl() est une fonction système puissante qui permet d'effectuer des opérations
			sur des périphériques en dehors des fichiers ordinaires. Les commandes
			envoyées via ioctl() sont spécifiques à chaque périphérique et sont
			définies par des macros spécifiques à ces périphériques.
		Elle est principalement utilisée pour interagir avec des dispositifs tels que
			les périphériques de terminal (pour configurer les paramètres du terminal),
			les périphériques réseau, ou les périphériques de stockage.
	
	Paramètres :
		* fd : un descripteur de fichier sur lequel l'opération doit être effectuée.
		Ce descripteur peut être obtenu par l'ouverture d'un fichier avec open() ou
		via des descripteurs standard tels que STDIN_FILENO, STDOUT_FILENO, ou
		STDERR_FILENO.
		* request : un code de commande qui spécifie l'opération à effectuer. Ces codes sont
		définis par des constantes spécifiques à chaque type de périphérique (par exemple,
		des périphériques de terminal, des périphériques de réseau, etc.).
		* ... : des arguments supplémentaires qui dépendent de la commande spécifique.
		Certains ioctl nécessitent un pointeur vers une structure, un entier, ou d'autres
		types de données.
	
	Retour :
		ioctl() retourne 0 en cas de succès.
		Si une erreur se produit, elle retourne -1 et définit errno pour indiquer
			l'erreur. Les erreurs courantes incluent EBADF (descripteur de fichier
			invalide), EINVAL (mauvaise commande), et ENOTTY (opération non supportée
			pour le type de fichier).

		ex :
		int main()
		{
			// Ouvrir un périphérique série (exemple : /dev/ttyS0)
			int fd = open("/dev/ttyS0", O_RDWR);
			if (fd == -1)
				return (perror("Erreur lors de l'ouverture du périphérique"), 1);

			// Récupérer les informations du port série
			struct serial_struct ss;
			if (ioctl(fd, TIOCGSERIAL, &ss) == -1)
				return (perror("Erreur lors de l'appel ioctl"), close(fd), 1);

			// Affichage des informations du port série
			printf("Nom du périphérique : /dev/ttyS0\n");
			printf("Port série baud rate : %d\n", ss.baud_base);
			printf("Numéro du port : %d\n", ss.port);

			// Fermeture du descripteur de fichier
			close(fd);
			return 0;
		}



45 : getenv
	#include <stdlib.h>

	char *getenv(const char *name);

	permet de récupérer la valeur d'une variable d'environnement. Les variables
	d'environnement sont des paires clé-valeur associées à l'environnement d'un
	processus, et getenv() permet d'accéder à leur valeur.

	Fonctionnement :
		getenv() recherche la variable d'environnement dans la liste des variables
			d'environnement du processus courant.
		Elle est généralement utilisée pour récupérer des informations liées à
			l'environnement, comme le répertoire de travail, les paramètres de configuration
			de l'utilisateur, ou les paramètres système.
	
	Paramètres :
		name : le nom de la variable d'environnement dont vous voulez obtenir la valeur.
		Ce nom est une chaîne de caractères qui doit être le nom exact de la variable
		d'environnement (par exemple, "HOME" pour le répertoire de l'utilisateur,
		"PATH" pour la liste des répertoires de recherche des exécutables, etc.).

	Retour :
		getenv() retourne une chaîne de caractères contenant la valeur de la variable
		d'environnement demandée, ou NULL si la variable d'environnement n'existe pas.

		ex :
		int main()
		{
			// Récupérer la valeur de la variable d'environnement "HOME"
			char *home = getenv("HOME");

			if (home != NULL)
				// Afficher la valeur de la variable d'environnement "HOME"
				printf("Le répertoire HOME est : %s\n", home);
			else
				printf("La variable d'environnement 'HOME' n'est pas définie.\n");

			return 0;
		}



46 : tcsetattr
	#include <termios.h>

	int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);

	est utilisée pour configurer les attributs d'un terminal (par exemple, un terminal
	série ou un terminal en ligne de commande). Elle permet de modifier les paramètres
	de contrôle du terminal, comme le mode d'entrée/sortie, le contrôle du flux, les
	délais de lecture, etc.

	Fonctionnement :
		tcsetattr() modifie les paramètres du terminal spécifié par le descripteur de
			fichier fd selon les valeurs définies dans la structure termios. Vous pouvez
			ainsi configurer des attributs comme le mode canonique (avec ou sans mise
			en tampon), les vitesses de transmission, et d'autres comportements liés
			aux entrées et sorties du terminal.
		Les modifications peuvent être appliquées immédiatement ou attendre la fin des
			écritures en cours, en fonction de la valeur de optional_actions.

	Paramètres :
		* fd : le descripteur de fichier du terminal que vous souhaitez configurer.
			Il peut s'agir d'un descripteur de fichier ouvert avec la fonction open()
			(par exemple, /dev/ttyS0, /dev/tty, ou STDIN_FILENO pour l'entrée standard).
		* optional_actions : spécifie les actions à entreprendre pour appliquer les
			nouveaux paramètres. Il peut prendre l'une des valeurs suivantes :
			- TCSANOW : applique immédiatement les modifications.
			- TCSADRAIN : attend que les écritures en cours se terminent avant d'appliquer
				les modifications.
			- TCSAFLUSH : attend que les écritures en cours se terminent et vide le tampon
				d'entrée avant d'appliquer les modifications.
		* termios_p : un pointeur vers une structure termios qui contient les nouveaux
			paramètres à appliquer au terminal. La structure termios contient des
			informations telles que les modes de contrôle du terminal (par exemple,
			c_cflag, c_iflag, c_oflag, etc.).

	Retour :
		tcsetattr() retourne 0 en cas de succès.
		En cas d'erreur, la fonction retourne -1 et définit errno pour indiquer l'erreur.

		ex :
		int main()
		{
			// Ouvrir le terminal (ici, l'entrée standard)
			int fd = STDIN_FILENO;

			// Créer une structure termios pour stocker les paramètres actuels
			struct termios oldtio, newtio;

			// Obtenir les paramètres actuels du terminal
			if (tcgetattr(fd, &oldtio) != 0)
				return (perror("tcgetattr"), 1);

			// Sauvegarder les paramètres actuels pour pouvoir les restaurer plus tard
			newtio = oldtio;

			// Configurer le terminal en mode non canonique (entrée ligne par ligne)
			newtio.c_lflag &= ~ICANON;  // Désactiver le mode canonique
			newtio.c_lflag &= ~ECHO;    // Désactiver l'écho des caractères

			// Appliquer les nouveaux paramètres immédiatement
			if (tcsetattr(fd, TCSANOW, &newtio) != 0)
				return (perror("tcgetattr"), 1);

			// Lecture d'un caractère sans mise en tampon (mode non canonique)
			char c;
			printf("Entrez un caractère : ");
			read(fd, &c, 1);
			printf("Vous avez entré : %c\n", c);

			// Restaurer les paramètres initiaux du terminal
			if (tcsetattr(fd, TCSANOW, &oldtio) != 0)
				return (perror("tcgetattr"), 1);

			return 0;
		}



47 : tcgetattr
	#include <termios.h>

	int tcgetattr(int fd, struct termios *termios_p);

	est utilisée pour récupérer les paramètres d'un terminal. Elle permet de lire
	les paramètres actuels de configuration d'un terminal, tels que les modes d'entrée,
	de sortie, les paramètres de vitesse de transmission, le contrôle du flux, etc.

	Fonctionnement :
		tcgetattr() permet de récupérer la configuration actuelle du terminal spécifié
			par le descripteur de fichier fd. Cela inclut les paramètres de ligne comme
			les modes d'entrée, de sortie, les débits de transmission, et d'autres options
			comme le contrôle du flux et les signaux.
		Les informations sont stockées dans la structure termios, qui peut ensuite être
			modifiée et appliquée via tcsetattr().

	Paramètres :
		* fd : le descripteur de fichier du terminal pour lequel vous souhaitez récupérer
			les paramètres. Il peut s'agir de STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO,
			ou d'un descripteur de fichier obtenu via open() pour un terminal, par exemple
			/dev/ttyS0 ou /dev/tty.
		* termios_p : un pointeur vers une structure termios qui sera remplie avec les
			paramètres actuels du terminal. La structure termios contient plusieurs champs
			utilisés pour configurer les attributs du terminal (par exemple, c_lflag,
			c_iflag, c_oflag, c_cflag, etc.).

	Retour :
		tcgetattr() retourne 0 en cas de succès.
		En cas d'erreur, elle retourne -1 et définit errno pour indiquer l'erreur.

		ex :
		int main()
		{
			// Ouvrir le terminal (ici, l'entrée standard)
			int fd = STDIN_FILENO;

			// Créer une structure termios pour stocker les paramètres
			struct termios term_params;

			// Récupérer les paramètres actuels du terminal
			if (tcgetattr(fd, &term_params) != 0)
				return (perror("tcgetattr"), 1);

			// Afficher quelques paramètres du terminal
			printf("Mode canonique activé : %s\n", (term_params.c_lflag & ICANON) ? "Oui" : "Non");
			printf("Echo des caractères activé : %s\n", (term_params.c_lflag & ECHO) ? "Oui" : "Non");
			printf("Baud rate d'entrée : %ld\n", (long) cfgetispeed(&term_params));
			printf("Baud rate de sortie : %ld\n", (long) cfgetospeed(&term_params));

			return 0;
		}



48 : tgetent
	#include <term.h>

	int tgetent(char *buf, const char *name);

	est utilisée pour lire une entrée dans la base de données des terminaux
	(généralement contenue dans le fichier /etc/termcap ou dans une base de
	données similaire) afin de récupérer les informations de configuration du
	terminal spécifié.

	Fonctionnement :
		tgetent() permet de récupérer des informations sur un terminal à partir de la
			base de données des terminaux. Cette base de données contient des
			informations sur différents types de terminaux et leurs capacités
			(par exemple, les séquences de contrôle pour changer les couleurs,
			la taille du terminal, etc.).
		L'entrée est récupérée à partir de la base de données et stockée dans le
			tampon buf, et vous pouvez ensuite utiliser d'autres fonctions comme
			tgetstr(), tgetnum(), ou tgetflag() pour extraire des informations
			spécifiques de cette entrée.

	Paramètres :
		buf : un tampon (pointeur vers une chaîne de caractères)où les informations du
			terminal seront stockées après l'appel de tgetent(). Ce tampon doit avoir
			une taille suffisante pour contenir les informations du terminal.
		name : le nom du terminal pour lequel vous souhaitez obtenir des informations.
			Ce nom peut être, par exemple, "xterm", "linux", ou tout autre nom de
			terminal valide.
	
	Retour :
		tgetent() retourne :
			- 1 en cas de succès, indiquant que l'entrée a été trouvée et chargée dans buf.
			- 0 si l'entrée n'a pas été trouvée (si le terminal spécifié n'existe pas dans
				la base de données des terminaux).
			- -1 en cas d'erreur (par exemple, si le fichier de base de données des
				terminaux est inaccessible).

		ex :
		int main()
		{
			// Tampon pour stocker les informations du terminal
			char *term_buffer = (char *)malloc(2048);  // Taille suffisante pour stocker les informations

			// Nom du terminal à récupérer (par exemple, "xterm")
			const char *term_name = "xterm";

			// Initialiser la base de données des terminaux et récupérer les informations
			if (tgetent(term_buffer, term_name) != 1)
			{
				fprintf(stderr, "Erreur lors de la récupération des informations du terminal '%s'\n", term_name);
				free(term_buffer);
				return 1;
			}

			// Récupérer la séquence d'échappement pour la couleur de fond
			char *bg_color = tgetstr("AB", &term_buffer);
			if (bg_color != NULL)
				printf("La séquence d'échappement pour changer la couleur de fond est : %s\n", bg_color);
			else
				printf("Pas de séquence d'échappement pour la couleur de fond.\n");

			// Libérer la mémoire allouée
			free(term_buffer);
			return 0;
		}



49 : tgetflag
	#include <term.h>

	int tgetflag(const char *id);

	permet de récupérer la valeur d'un attribut (ou capacité) du terminal à partir de la
	base de données des terminaux (généralement stockée dans `/etc/termcap ou dans une
	base de données similaire). Elle retourne un indicateur booléen (vrai ou faux) pour
	un attribut spécifique.

	Fonctionnement :
		tgetflag() lit les informations d'un terminal à partir de la base de données
			des terminaux. Vous utilisez cette fonction pour vérifier la présence ou
			l'activation de certaines capacités d'un terminal.
		Par exemple, vous pouvez l'utiliser pour vérifier si un terminal supporte
			l'auto-marginalisation, les retours en arrière, ou d'autres capacités
			spécifiques du terminal.
		L'identifiant passé en argument correspond à un nom de capacité et doit être
			une chaîne de caractères valide.
	
	Paramètres :
		id : Une chaîne de caractères qui représente le nom de la capacité du terminal
			que vous souhaitez vérifier. Ce nom est généralement un code à deux lettres
			qui identifie un attribut particulier, par exemple :
			- AM : Le terminal gère l'auto-marginalisation (le retour automatique à la
				ligne).
			- BS : Le terminal utilise des retours en arrière.
			- MC : Le terminal gère les couleurs (en mode texte).
	
	Retour :
		tgetflag() retourne 1 si la capacité demandée est activée pour le terminal
			(indicateur vrai).
		Elle retourne 0 si la capacité est désactivée ou non disponible pour le terminal
			(indicateur faux).
		Si une erreur survient ou si le nom de capacité n'est pas valide, la fonction
			retourne -1.

		ex :
		int main()
		{
			// Nom du terminal à vérifier (par exemple "xterm")
			const char *term_name = "xterm";

			// Tampon pour stocker les informations du terminal
			char *term_buffer = (char *)malloc(2048);

			// Initialiser la base de données des terminaux et récupérer les informations
			if (tgetent(term_buffer, term_name) != 1)
			{
				fprintf(stderr, "Erreur lors de la récupération des informations du terminal '%s'\n", term_name);
				free(term_buffer);
				return 1;
			}

			// Vérifier si l'auto-marginalisation (AM) est supportée
			if (tgetflag("AM"))
				printf("Le terminal supporte l'auto-marginalisation.\n");
			else
				printf("Le terminal ne supporte pas l'auto-marginalisation.\n");

			// Vérifier si le retour en arrière (BS) est supporté
			if (tgetflag("BS"))
				printf("Le terminal supporte le retour en arrière.\n");
			else
				printf("Le terminal ne supporte pas le retour en arrière.\n");

			// Libérer la mémoire allouée
			free(term_buffer);
			return 0;
		}



50 : tgetnum
	#include <term.h>

	int tgetnum(const char *id);

	permet de récupérer une valeur numérique associée à une capacité spécifique d'un
	terminal à partir de la base de données des terminaux. Cela permet de connaître
	des attributs qui sont représentés par des valeurs numériques (par exemple, la
	largeur ou la hauteur du terminal, les couleurs disponibles, etc.).

	Fonctionnement :
		tgetnum() permet d'obtenir des valeurs numériques spécifiques d'un terminal à
			partir de la base de données des terminaux. Ces valeurs sont souvent utilisées
			pour ajuster l'affichage en fonction des capacités du terminal (par exemple,
			la taille de l'écran).
		L'identifiant id que vous passez à tgetnum() correspond à un nom de capacité du
			terminal. Si la capacité spécifiée est présente dans la base de données,
			la fonction retourne sa valeur numérique.
	
	Paramètres :
		id : une chaîne de caractères qui représente le nom de la capacité du terminal
			que vous souhaitez récupérer. Ce nom correspond à un code à deux lettres,
			par exemple :
			- co : le nombre de colonnes du terminal.
			- li : le nombre de lignes du terminal.
	
	Retour :
		tgetnum() retourne une valeur entière correspondant à la capacité du terminal
			spécifiée par id.
			Si la capacité est trouvée et est un nombre valide, la fonction retourne
				cette valeur.
			Si la capacité n'est pas trouvée ou si la valeur est invalide, la fonction
				retourne -1.

		ex :
		int main()
		{
			// Nom du terminal à vérifier (par exemple "xterm")
			const char *term_name = "xterm";

			// Tampon pour stocker les informations du terminal
			char *term_buffer = (char *)malloc(2048);

			// Initialiser la base de données des terminaux et récupérer les informations
			if (tgetent(term_buffer, term_name) != 1)
			{
				fprintf(stderr, "Erreur lors de la récupération des informations du terminal '%s'\n", term_name);
				free(term_buffer);
				return 1;
			}

			// Récupérer le nombre de colonnes du terminal
			int cols = tgetnum("co");
			if (cols == -1)
				printf("Impossible de récupérer le nombre de colonnes.\n");
			else
				printf("Le terminal a %d colonnes.\n", cols);

			// Récupérer le nombre de lignes du terminal
			int lines = tgetnum("li");
			if (lines == -1)
				printf("Impossible de récupérer le nombre de lignes.\n");
			else
				printf("Le terminal a %d lignes.\n", lines);

			// Libérer la mémoire allouée
			free(term_buffer);
			return 0;
		}



51 : tgetstr
	#include <term.h>

	char *tgetstr(const char *id, char **area);

	permet de récupérer une chaîne de caractères associée à une capacité spécifique
	d'un terminal à partir de la base de données des terminaux. Elle est souvent
	utilisée pour récupérer des séquences d'échappement qui contrôlent l'affichage
	ou la configuration d'un terminal, telles que des séquences pour changer la
	couleur de fond ou de texte, ou pour ajuster d'autres paramètres du terminal.

	Fonctionnement :
		tgetstr() récupère la chaîne de caractères associée à une capacité du terminal
			à partir de la base de données des terminaux.
		Vous devez fournir un tampon (ou un pointeur vers un tampon) où la chaîne
			d'échappement sera stockée. Si area est NULL, la mémoire sera allouée
			dynamiquement.
		La fonction permet de récupérer des séquences d'échappement qui sont souvent
			utilisées pour contrôler des éléments spécifiques du terminal, comme le
			déplacement du curseur, les couleurs, ou l'activation de certains modes.
	
	Paramètres :
		id : une chaîne de caractères qui représente le nom de la capacité du terminal
			que vous souhaitez récupérer. Ce nom correspond à un code à deux lettres,
			par exemple :
			- cm : la séquence d'échappement pour déplacer le curseur (capacité de
				"cursor movement").
			- so : la séquence d'échappement pour activer l'attribut "standout"
				(par exemple, pour rendre le texte gras ou inversé).
			- se : la séquence d'échappement pour désactiver l'attribut "standout".
		area : un pointeur vers un tampon où la chaîne d'échappement sera stockée. Ce
			tampon est utilisé pour allouer de la mémoire pour la séquence récupérée.
			Ce pointeur peut être un pointeur vers un tampon déjà alloué ou peut être NULL.
	
	Retour :
		tgetstr() retourne un pointeur vers la chaîne de caractères récupérée (la
			séquence d'échappement).
		Si la capacité n'est pas trouvée ou si un problème survient, elle retourne NULL.

		ex :
		int main()
		{
			// Nom du terminal à vérifier (par exemple "xterm")
			const char *term_name = "xterm";

			// Tampon pour stocker les informations du terminal
			char *term_buffer = (char *)malloc(2048);

			// Initialiser la base de données des terminaux et récupérer les informations
			if (tgetent(term_buffer, term_name) != 1)
			{
				fprintf(stderr, "Erreur lors de la récupération des informations du terminal '%s'\n", term_name);
				free(term_buffer);
				return 1;
			}

			// Tampon pour la séquence d'échappement
			char *cursor_move;

			// Récupérer la séquence d'échappement pour déplacer le curseur (capacité "cm")
			cursor_move = tgetstr("cm", &term_buffer);

			if (cursor_move != NULL)
				// Afficher la séquence d'échappement pour déplacer le curseur
				printf("La séquence pour déplacer le curseur est : %s\n", cursor_move);
			else
				printf("Impossible de récupérer la séquence pour déplacer le curseur.\n");

			// Libérer la mémoire allouée
			free(term_buffer);
			return 0;
		}



52 : tgoto
	#include <term.h>

	char *tgoto(const char *cap, int col, int row);

	est utilisée pour générer une séquence d'échappement de terminal qui déplace
	le curseur à une position spécifique dans le terminal. Elle utilise les capacités
	du terminal définies dans la base de données des terminaux, et elle prend en compte
	le mouvement du curseur sous forme de séquence d'échappement.

	Fonctionnement :
		tgoto() génère une séquence d'échappement basée sur le modèle cap (typiquement
			récupéré avec tgetstr()) et les coordonnées col et row.
		Cette séquence d'échappement peut être envoyée au terminal pour déplacer le
			curseur à la position spécifiée.
		tgoto() est utilisée après avoir récupéré une capacité de déplacement de
			curseur d'un terminal (généralement avec tgetstr("cm", &area)), et cette
			capacité est ensuite utilisée pour générer la séquence d'échappement avec
			les coordonnées fournies.
	
	Paramètres :
		cap : Une chaîne de caractères représentant la capacité de contrôle du terminal
			qui déplace le curseur (souvent associée à la capacité cm pour le mouvement
			du curseur).
		col : La colonne cible où déplacer le curseur (indexée à partir de 0).
		row : La ligne cible où déplacer le curseur (indexée à partir de 0).
	
	Retour :
		tgoto() retourne une chaîne de caractères contenant la séquence d'échappement
			nécessaire pour déplacer le curseur à la position spécifiée.
		Si la séquence d'échappement est invalide ou si un problème survient, la fonction
			retourne NULL.

		ex :
		int main()
		{
			// Nom du terminal à vérifier (par exemple "xterm")
			const char *term_name = "xterm";

			// Tampon pour stocker les informations du terminal
			char *term_buffer = (char *)malloc(2048);

			// Initialiser la base de données des terminaux et récupérer les informations
			if (tgetent(term_buffer, term_name) != 1)
			{
				fprintf(stderr, "Erreur lors de la récupération des informations du terminal '%s'\n", term_name);
				free(term_buffer);
				return 1;
			}

			// Tampon pour la séquence d'échappement du curseur
			char *cursor_move;

			// Récupérer la séquence d'échappement pour le mouvement du curseur (capacité "cm")
			cursor_move = tgetstr("cm", &term_buffer);

			if (cursor_move != NULL)
			{
				// Utiliser tgoto() pour générer la séquence pour déplacer le curseur à la colonne 10, ligne 5
				char *sequence = tgoto(cursor_move, 10, 5);
				
				if (sequence != NULL)
					// Afficher la séquence d'échappement pour déplacer le curseur
					printf("La séquence pour déplacer le curseur est : %s\n", sequence);
				else
					printf("Impossible de générer la séquence pour déplacer le curseur.\n");
			}
			else
				printf("Impossible de récupérer la séquence de mouvement du curseur.\n");

			// Libérer la mémoire allouée
			free(term_buffer);
			return 0;
		}



53 : tputs
	#include <term.h>

	int tputs(const char *str, int affcnt, int (*putc)(int));

	permet d'envoyer une séquence d'échappement au terminal. Elle est principalement
	utilisée pour exécuter des commandes de contrôle sur le terminal, telles que déplacer
	le curseur ou modifier l'affichage (par exemple, activer ou désactiver des attributs
	comme le texte en gras, changer la couleur, etc.). Elle prend en compte la vitesse
	de sortie du terminal et s'assure que les séquences sont envoyées à une vitesse
	appropriée.

	Fonctionnement :
		tputs() est une fonction utilisée pour envoyer des séquences d'échappement au
			terminal. Elle s'assure que les séquences sont envoyées de manière à respecter
			les capacités du terminal, par exemple en ajustant la vitesse de transmission
			pour correspondre à la capacité du terminal à traiter les caractères.
		Elle est souvent utilisée pour des capacités qui modifient l'affichage, telles
			que cm pour déplacer le curseur, so pour activer le texte "standout" (par
			exemple, gras ou inversé), ou se pour désactiver ce mode.
	
	Paramètres :
		str : La chaîne de caractères représentant la séquence d'échappement à envoyer
			au terminal.
		affcnt : Le nombre d'affichages ou répétitions de la séquence d'échappement.
			Si ce paramètre est 1, la séquence est envoyée une seule fois.
		putc : Un pointeur vers une fonction qui sera utilisée pour envoyer chaque
			caractère de la chaîne str au terminal. Généralement, cette fonction est
			putchar ou une fonction personnalisée qui utilise un mécanisme d'output
			spécifique, comme l'écriture dans un fichier.
	
	Retour :
		tputs() retourne un entier qui dépend du succès de l'exécution de la séquence
		d'échappement. En cas de succès, il renvoie une valeur non nulle, sinon une
		valeur nulle est retournée pour signaler une erreur.

		ex :
		int putchar_custom(int c)
		{
			return putchar(c); // Par défaut, on envoie les caractères à stdout
		}

		int main()
		{
			// Nom du terminal à vérifier (par exemple "xterm")
			const char *term_name = "xterm";

			// Tampon pour stocker les informations du terminal
			char *term_buffer = (char *)malloc(2048);

			// Initialiser la base de données des terminaux et récupérer les informations
			if (tgetent(term_buffer, term_name) != 1)
			{
				fprintf(stderr, "Erreur lors de la récupération des informations du terminal '%s'\n", term_name);
				free(term_buffer);
				return 1;
			}

			// Récupérer la séquence d'échappement pour activer le mode "standout" (texte en gras ou inversé)
			char *standout = tgetstr("so", &term_buffer);
			if (standout != NULL)
				// Envoyer la séquence d'échappement pour activer le mode "standout"
				tputs(standout, 1, putchar_custom);

			// Déplacer le curseur à la colonne 10, ligne 5
			char *cursor_move = tgetstr("cm", &term_buffer);
			if (cursor_move != NULL)
			{
				char *cursor_position = tgoto(cursor_move, 10, 5);
				if (cursor_position != NULL)
					// Envoyer la séquence pour déplacer le curseur
					tputs(cursor_position, 1, putchar_custom);
			}

			// Afficher un message en mode "standout"
			printf("Texte en mode standout (gras ou inversé).\n");

			// Désactiver le mode "standout"
			char *standout_off = tgetstr("se", &term_buffer);
			if (standout_off != NULL)
				tputs(standout_off, 1, putchar_custom);

			// Libérer la mémoire allouée
			free(term_buffer);
			return 0;
		}